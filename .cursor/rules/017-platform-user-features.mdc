---
description:
globs:
alwaysApply: false
---
description: Apply WHEN implementing user-related features that need to work across multi-tenant platforms, including authentication, permissions, and user management
globs: "**/auth/**/*.{ts,js,tsx,jsx}, **/users/**/*.{ts,js,tsx,jsx}, **/profile/**/*.{ts,js,tsx,jsx}"

# Platform User Features

This document outlines the requirements and best practices for implementing user-related features in multi-tenant platform applications.

## Core Requirements

- **REQUIRED**: Implement secure authentication using established identity providers
- **REQUIRED**: Support consistent user identity across platform and organization levels
- **REQUIRED**: Implement role-based access control for all platform features
- **REQUIRED**: Maintain secure user sessions with proper timeout and refresh mechanisms
- **REQUIRED**: Create audit trails for important user actions and session events

## Authentication Implementation

### Authentication Provider Integration

```typescript
// Authentication component with multiple providers
import { SignIn } from "@clerk/nextjs";

export function AuthenticationForm() {
  return (
    <div className="mx-auto flex w-full flex-col justify-center space-y-6 sm:w-[350px]">
      <div className="flex flex-col space-y-2 text-center">
        <h1 className="text-2xl font-semibold tracking-tight">
          Welcome to the Platform
        </h1>
        <p className="text-sm text-muted-foreground">
          Sign in to your account to continue
        </p>
      </div>
      
      <SignIn 
        path="/sign-in"
        routing="path"
        signUpUrl="/sign-up"
        redirectUrl="/dashboard"
        appearance={{
          elements: {
            formButtonPrimary: "bg-primary text-primary-foreground hover:bg-primary/90",
            card: "bg-card border border-border",
          },
        }}
      />
    </div>
  );
}
```

### Authentication Methods

- Support multiple authentication methods:
  - Email/password
  - Single Sign-On (SSO) integration
  - OAuth with major providers
  - Magic links for passwordless authentication
  - Multi-factor authentication for sensitive operations
- Implement consistent authentication flows across the application
- Provide clear feedback for authentication failures and success

## User Identity Management

### User Profile Data Structure

```typescript
// User profile schema implementation
import { z } from "zod";

// User schema for validation
export const userProfileSchema = z.object({
  id: z.string().optional(), // Generated by auth provider
  email: z.string().email({
    message: "Please enter a valid email address",
  }),
  name: z.string().min(2, {
    message: "Name must be at least 2 characters",
  }),
  image: z.string().url().optional(),
  title: z.string().optional(),
  bio: z.string().max(160).optional(),
  location: z.string().optional(),
  timezone: z.string().optional(),
  notificationPreferences: z.object({
    email: z.boolean().default(true),
    browser: z.boolean().default(true),
    mobile: z.boolean().default(true),
  }).optional(),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
});

export type UserProfile = z.infer<typeof userProfileSchema>;

// Usage for profile update
export async function updateUserProfile(userId: string, data: Partial<UserProfile>) {
  // Validate data
  const validated = userProfileSchema.partial().parse(data);
  
  try {
    // Update in database
    const updatedUser = await db.user.update({
      where: { id: userId },
      data: {
        ...validated,
        updatedAt: new Date(),
      },
    });
    
    // Sync with auth provider if needed
    if (validated.email || validated.name) {
      await syncAuthProviderProfile(userId, validated);
    }
    
    return updatedUser;
  } catch (error) {
    logger.error("Failed to update user profile", { userId, error });
    throw new Error("Failed to update user profile");
  }
}
```

### User Onboarding and Lifecycle

- Implement proper user onboarding and account setup flows
- Support profile updates and preference management
- Handle account deactivation and deletion securely
- Maintain audit logs of identity changes
- Implement proper GDPR compliance for user data

## Permission Management

### Role-Based Access Control (RBAC)

```typescript
// Permission checking middleware
import { NextApiRequest, NextApiResponse } from "next";
import { getAuth } from "@clerk/nextjs/server";

// Define permission types
export type Permission = 
  | "platform:admin"
  | "platform:user"
  | "org:admin"
  | "org:member"
  | "org:viewer";

// Get user permissions
export async function getUserPermissions(userId: string): Promise<Permission[]> {
  // Get platform-level roles
  const platformRoles = await db.userRole.findMany({
    where: { userId },
  });
  
  // Map roles to permissions
  const permissions: Permission[] = platformRoles.flatMap(role => {
    switch (role.name) {
      case "admin":
        return ["platform:admin", "platform:user"];
      case "user":
        return ["platform:user"];
      default:
        return [];
    }
  });
  
  return permissions;
}

// Get organization-specific permissions
export async function getUserOrgPermissions(
  userId: string,
  orgId: string
): Promise<Permission[]> {
  const member = await db.organizationMember.findUnique({
    where: {
      userId_organizationId: {
        userId,
        organizationId: orgId,
      },
    },
  });
  
  if (!member) return [];
  
  switch (member.role) {
    case "owner":
    case "admin":
      return ["org:admin", "org:member", "org:viewer"];
    case "member":
      return ["org:member", "org:viewer"];
    case "viewer":
      return ["org:viewer"];
    default:
      return [];
  }
}

// Permission middleware
export function withPermission(permission: Permission) {
  return async (req: NextApiRequest, res: NextApiResponse, next: () => void) => {
    const { userId } = getAuth(req);
    
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    
    // Get permissions
    let permissions = await getUserPermissions(userId);
    
    // Add org permissions if org ID provided
    const orgId = req.headers["x-organization-id"] as string;
    if (orgId) {
      const orgPermissions = await getUserOrgPermissions(userId, orgId);
      permissions = [...permissions, ...orgPermissions];
    }
    
    // Check permission
    if (!permissions.includes(permission)) {
      return res.status(403).json({ error: "Forbidden" });
    }
    
    // Permission granted, continue
    return next();
  };
}

// Usage in API route
export default withPermission("org:admin")(async (req, res) => {
  // Handle the request for org admins only
  // ...
});
```

### Permission Models

- Create a flexible permission model that can evolve with the platform
- Implement hierarchical roles (e.g., viewers inherit from members)
- Support custom permission sets for specialized roles
- Add permission checks in both UI components and API routes
- Provide clear feedback for permission-denied scenarios

## Session Management

### Secure Session Handling

```typescript
// Session management component
export function ActiveSessionsTable() {
  const [sessions, setSessions] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const { toast } = useToast();
  
  useEffect(() => {
    async function loadSessions() {
      try {
        setIsLoading(true);
        const response = await fetch('/api/user/sessions');
        const data = await response.json();
        setSessions(data.sessions);
      } catch (error) {
        toast({
          title: "Failed to load sessions",
          description: "Please try again later",
          variant: "destructive",
        });
      } finally {
        setIsLoading(false);
      }
    }
    
    loadSessions();
  }, [toast]);
  
  const handleTerminateSession = async (sessionId) => {
    try {
      await fetch(`/api/user/sessions/${sessionId}`, {
        method: 'DELETE',
      });
      
      // Remove from local state
      setSessions(sessions.filter(session => session.id !== sessionId));
      
      toast({
        title: "Session terminated",
        description: "The session has been successfully ended",
      });
    } catch (error) {
      toast({
        title: "Failed to terminate session",
        description: "Please try again later",
        variant: "destructive",
      });
    }
  };
  
  if (isLoading) {
    return <LoadingSpinner />;
  }
  
  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold tracking-tight">Active Sessions</h2>
      
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Device</TableHead>
            <TableHead>Location</TableHead>
            <TableHead>Last Active</TableHead>
            <TableHead>Status</TableHead>
            <TableHead className="text-right">Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {sessions.length === 0 ? (
            <TableRow>
              <TableCell colSpan={5} className="text-center">
                No active sessions found
              </TableCell>
            </TableRow>
          ) : (
            sessions.map((session) => (
              <TableRow key={session.id}>
                <TableCell>
                  <div className="flex items-center gap-2">
                    <DeviceIcon type={session.deviceType} className="h-4 w-4" />
                    <span>{session.deviceName}</span>
                    {session.isCurrent && (
                      <Badge variant="outline" className="ml-2">
                        Current
                      </Badge>
                    )}
                  </div>
                </TableCell>
                <TableCell>{session.location || 'Unknown'}</TableCell>
                <TableCell>{formatDate(session.lastActiveAt)}</TableCell>
                <TableCell>
                  <Badge 
                    variant={session.isActive ? "default" : "secondary"}
                  >
                    {session.isActive ? 'Active' : 'Inactive'}
                  </Badge>
                </TableCell>
                <TableCell className="text-right">
                  <Button
                    variant="ghost"
                    size="sm"
                    disabled={session.isCurrent}
                    onClick={() => handleTerminateSession(session.id)}
                  >
                    {session.isCurrent ? 'Current Session' : 'Terminate'}
                  </Button>
                </TableCell>
              </TableRow>
            ))
          )}
        </TableBody>
      </Table>
    </div>
  );
}
```

### Session Security Features

- Support multiple active sessions with proper device management
- Add session timeout and refresh mechanisms
- Create audit trails for important session events
- Allow users to review and terminate active sessions
- Implement suspicious activity detection

## User Preferences

### Preference Management System

```typescript
// User preferences hook
import { useState, useEffect } from 'react';
import { useDebounce } from '@/hooks/useDebounce';
import { useAuth } from '@clerk/nextjs';

export interface UserPreferences {
  theme: 'light' | 'dark' | 'system';
  sidebarCollapsed: boolean;
  notifications: {
    email: boolean;
    push: boolean;
    inApp: boolean;
  };
  dashboard: {
    defaultView: 'list' | 'grid';
    hiddenWidgets: string[];
  };
}

const defaultPreferences: UserPreferences = {
  theme: 'system',
  sidebarCollapsed: false,
  notifications: {
    email: true,
    push: true,
    inApp: true,
  },
  dashboard: {
    defaultView: 'list',
    hiddenWidgets: [],
  },
};

export function useUserPreferences() {
  const { userId } = useAuth();
  const [preferences, setPreferences] = useState<UserPreferences>(defaultPreferences);
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  
  // Load preferences
  useEffect(() => {
    if (!userId) return;
    
    async function loadPreferences() {
      try {
        setIsLoading(true);
        const response = await fetch('/api/user/preferences');
        
        if (response.ok) {
          const data = await response.json();
          setPreferences({
            ...defaultPreferences,
            ...data.preferences,
          });
        }
      } catch (error) {
        console.error('Failed to load preferences', error);
      } finally {
        setIsLoading(false);
      }
    }
    
    loadPreferences();
  }, [userId]);
  
  // Debounce changes to reduce API calls
  const debouncedPreferences = useDebounce(preferences, 500);
  
  // Save preferences when they change
  useEffect(() => {
    if (!userId || isLoading) return;
    
    async function savePreferences() {
      try {
        setIsSaving(true);
        await fetch('/api/user/preferences', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ preferences: debouncedPreferences }),
        });
      } catch (error) {
        console.error('Failed to save preferences', error);
      } finally {
        setIsSaving(false);
      }
    }
    
    savePreferences();
  }, [debouncedPreferences, userId, isLoading]);
  
  // Update a specific preference
  const updatePreference = <K extends keyof UserPreferences>(
    key: K,
    value: UserPreferences[K]
  ) => {
    setPreferences(prev => ({
      ...prev,
      [key]: value,
    }));
  };
  
  // Update a nested preference
  const updateNestedPreference = <
    K extends keyof UserPreferences,
    N extends keyof UserPreferences[K]
  >(
    key: K,
    nestedKey: N,
    value: UserPreferences[K][N]
  ) => {
    setPreferences(prev => ({
      ...prev,
      [key]: {
        ...prev[key],
        [nestedKey]: value,
      },
    }));
  };
  
  return {
    preferences,
    isLoading,
    isSaving,
    updatePreference,
    updateNestedPreference,
  };
}
```

### Standard Preference Categories

- Theme preferences (light/dark mode)
- Notification preferences (email, push, in-app)
- UI customization options (layout, density)
- Feature enablement preferences
- Regional settings (language, timezone, format)

## Multi-organization Relationships

### Organization Membership Management

```typescript
// Database schema (Prisma example)
/*
model User {
  id          String   @id
  email       String   @unique
  name        String
  memberships OrganizationMember[]
}

model Organization {
  id          String   @id @default(cuid())
  name        String
  members     OrganizationMember[]
  invites     OrganizationInvite[]
}

model OrganizationMember {
  userId        String
  organizationId String
  role          String
  joinedAt      DateTime @default(now())
  
  user          User @relation(fields: [userId], references: [id])
  organization  Organization @relation(fields: [organizationId], references: [id])
  
  @@id([userId, organizationId])
}

model OrganizationInvite {
  id            String   @id @default(cuid())
  email         String
  organizationId String
  role          String
  token         String   @unique
  expiresAt     DateTime
  invitedBy     String
  createdAt     DateTime @default(now())
  
  organization  Organization @relation(fields: [organizationId], references: [id])
}
*/
```

### Key Organization Features

- Support users belonging to multiple organizations
- Implement organization switching functionality
- Handle organization invites and membership requests
- Maintain history of organization memberships
- Create clear organization role definitions
- Support organization settings and administration

## User Interface Patterns

### Profile and Settings Interface

```typescript
// User settings layout
export function UserSettingsLayout({ children }) {
  return (
    <div className="container py-8">
      <div className="flex flex-col gap-8 md:flex-row">
        <aside className="md:w-64 shrink-0">
          <nav className="space-y-1">
            <SettingsNavLink href="/settings/profile">
              Profile
            </SettingsNavLink>
            <SettingsNavLink href="/settings/account">
              Account Security
            </SettingsNavLink>
            <SettingsNavLink href="/settings/notifications">
              Notifications
            </SettingsNavLink>
            <SettingsNavLink href="/settings/preferences">
              Preferences
            </SettingsNavLink>
            <SettingsNavLink href="/settings/api-keys">
              API Keys
            </SettingsNavLink>
            <SettingsNavLink href="/settings/sessions">
              Active Sessions
            </SettingsNavLink>
            <SettingsNavLink href="/settings/billing">
              Billing
            </SettingsNavLink>
          </nav>
        </aside>
        
        <main className="flex-1">
          <div className="space-y-6">
            {children}
          </div>
        </main>
      </div>
    </div>
  );
}

// Settings navigation link component
function SettingsNavLink({ href, children }) {
  const router = useRouter();
  const isActive = router.pathname === href;
  
  return (
    <Link
      href={href}
      className={cn(
        "flex items-center gap-2 rounded-md px-3 py-2 text-sm font-medium",
        isActive
          ? "bg-muted text-foreground"
          : "text-muted-foreground hover:bg-muted hover:text-foreground"
      )}
    >
      {children}
    </Link>
  );
}
```

### User Interface Components

Implement standardized UI components for:
- User avatars and badges
- Profile completion indicators
- Authentication forms
- Permission-aware action buttons
- Organization switchers
- User selection and assignment interfaces

## Security Considerations

- Implement proper rate limiting for authentication attempts
- Add CSRF protection for all authentication and user actions
- Store and transmit user data securely
- Implement proper password policies and reset flows
- Support multi-factor authentication for sensitive operations
- Create comprehensive security monitoring for user activities
- Implement proper session isolation and invalidation

## Best Practices

1. **Security First**: Always prioritize security for user-related features
2. **Progressive Enhancement**: Build a solid core experience, then enhance
3. **Feedback Quality**: Provide clear, helpful feedback for user actions
4. **Accessibility**: Ensure all user features are accessible
5. **Performance**: Optimize user features for quick interactions
6. **Error Handling**: Implement comprehensive error handling for user flows
7. **Testing**: Test user features across different scenarios and edge cases

## Implementation Checklist

- [ ] Implement secure authentication with an established provider
- [ ] Create comprehensive user profile and identity management
- [ ] Establish role-based access control system
- [ ] Implement secure session management
- [ ] Create user preference management system
- [ ] Set up organization membership and relationship handling
- [ ] Build standardized profile and settings interfaces
- [ ] Implement proper security measures for all user features
- [ ] Add comprehensive logging and monitoring
